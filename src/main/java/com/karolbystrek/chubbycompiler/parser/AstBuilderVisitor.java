package com.karolbystrek.chubbycompiler.parser;

import com.karolbystrek.chubbycompiler.ChubbyBaseVisitor;
import com.karolbystrek.chubbycompiler.ChubbyParser;
import com.karolbystrek.chubbycompiler.ast.AstNode;
import com.karolbystrek.chubbycompiler.ast.ClassDefinitionNode;
import com.karolbystrek.chubbycompiler.ast.ClassMemberNode;
import com.karolbystrek.chubbycompiler.ast.ConstructorDefinitionNode;
import com.karolbystrek.chubbycompiler.ast.FunctionDefinitionNode;
import com.karolbystrek.chubbycompiler.ast.ImportStatementNode;
import com.karolbystrek.chubbycompiler.ast.ParameterNode;
import com.karolbystrek.chubbycompiler.ast.ProgramNode;
import com.karolbystrek.chubbycompiler.ast.TypeNode;
import com.karolbystrek.chubbycompiler.ast.VariableDefinitionNode;
import com.karolbystrek.chubbycompiler.ast.Visibility;
import com.karolbystrek.chubbycompiler.ast.VisibilityNode;
import com.karolbystrek.chubbycompiler.ast.expression.*;
import com.karolbystrek.chubbycompiler.ast.expression.literal.*;
import com.karolbystrek.chubbycompiler.ast.statement.*;
import com.karolbystrek.chubbycompiler.ast.statement.block.*;
import com.karolbystrek.chubbycompiler.ast.statement.simple.*;
import com.karolbystrek.chubbycompiler.ast.statement.simple.AssignmentOperatorNode;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Visitor implementation that builds an Abstract Syntax Tree (AST)
 * from the parse tree generated by ANTLR based on the Chubby grammar.
 */
public class AstBuilderVisitor extends ChubbyBaseVisitor<AstNode> {

    private int getLine(ParserRuleContext ctx) {
        return ctx.getStart().getLine();
    }

    private int getColumn(ParserRuleContext ctx) {
        return ctx.getStart().getCharPositionInLine();
    }

    private int getLine(Token token) {
        return token.getLine();
    }

    private int getColumn(Token token) {
        return token.getCharPositionInLine();
    }

    @Override
    public AstNode visitProgram(ChubbyParser.ProgramContext ctx) {
        List<ImportStatementNode> imports = ctx.import_statement().stream()
                .map(this::visitImport_statement)
                .map(ImportStatementNode.class::cast)
                .collect(Collectors.toList());

        List<ClassDefinitionNode> classDefinitions = ctx.class_definition().stream()
                .map(this::visitClass_definition)
                .map(ClassDefinitionNode.class::cast)
                .collect(Collectors.toList());

        return new ProgramNode(imports, classDefinitions, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitImport_statement(ChubbyParser.Import_statementContext ctx) {
        String qualifiedIdentifier = ctx.IDENTIFIER().getText();
        return new ImportStatementNode(qualifiedIdentifier, getLine(ctx.IDENTIFIER().getSymbol()), getColumn(ctx.IDENTIFIER().getSymbol()));
    }

    @Override
    public AstNode visitClass_definition(ChubbyParser.Class_definitionContext ctx) {
        Visibility visibility = ((VisibilityNode) visitVisibility_modifier(ctx.visibility_modifier())).getVisibility();
        String name = ctx.IDENTIFIER().getText();
        List<ClassMemberNode> members = ctx.class_member().stream()
                .map(this::visitClass_member)
                .map(ClassMemberNode.class::cast)
                .collect(Collectors.toList());

        return new ClassDefinitionNode(visibility, name, members, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitClass_member(ChubbyParser.Class_memberContext ctx) {
        if (ctx.function_definition() != null) {
            return visitFunction_definition(ctx.function_definition());
        } else if (ctx.constructor_definition() != null) {
            return visitConstructor_definition(ctx.constructor_definition());
        } else if (ctx.variable_definition() != null) {
            return visitVariable_definition(ctx.variable_definition());
        }
        return null;
    }

    @Override
    public AstNode visitConstructor_definition(ChubbyParser.Constructor_definitionContext ctx) {
        Visibility visibility = ctx.visibility_modifier() != null ?
                ((VisibilityNode) visitVisibility_modifier(ctx.visibility_modifier())).getVisibility() :
                Visibility.PUBLIC;
        String name = ctx.IDENTIFIER().getText();
        List<ParameterNode> parameters = ctx.parameter_list() != null ?
                ((ParameterListNode) visitParameter_list(ctx.parameter_list())).getParameters() :
                Collections.emptyList();

        List<StatementNode> body = ctx.statement().stream()
                .map(this::visitStatement)
                .map(StatementNode.class::cast)
                .collect(Collectors.toList());

        return new ConstructorDefinitionNode(visibility, name, parameters, body, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitVariable_definition(ChubbyParser.Variable_definitionContext ctx) {
        Visibility visibility = ((VisibilityNode) visitVisibility_modifier(ctx.visibility_modifier())).getVisibility();
        boolean isStatic = ctx.STATIC() != null;
        boolean isConst = ctx.CONST() != null;
        TypeNode type = (TypeNode) visitType_specifier(ctx.type_specifier());
        int arrayDimensions = ctx.LEFT_SQUARE().size();
        if (arrayDimensions > 0) {
            type = new TypeNode(type.getBaseTypeName(), arrayDimensions, type.getLineNumber(), type.getColumnNumber());
        }
        String name = ctx.IDENTIFIER().getText();
        ExpressionNode initializer = ctx.expression() != null ? (ExpressionNode) visitExpression(ctx.expression()) : null;

        return new VariableDefinitionNode(visibility, type, name, isStatic, isConst, initializer, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitFunction_definition(ChubbyParser.Function_definitionContext ctx) {
        Visibility visibility = ((VisibilityNode) visitVisibility_modifier(ctx.visibility_modifier())).getVisibility();
        boolean isStatic = ctx.STATIC() != null;
        String name = ctx.IDENTIFIER().getText();
        List<ParameterNode> parameters = ctx.parameter_list() != null ?
                ((ParameterListNode) visitParameter_list(ctx.parameter_list())).getParameters() :
                Collections.emptyList();
        TypeNode returnType = (TypeNode) visitReturn_type(ctx.return_type());
        List<StatementNode> body = ctx.statement().stream()
                .map(this::visitStatement)
                .map(StatementNode.class::cast)
                .collect(Collectors.toList());

        return new FunctionDefinitionNode(visibility, isStatic, name, parameters, returnType, body, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitVisibility_modifier(ChubbyParser.Visibility_modifierContext ctx) {
        Visibility visibility;
        Token token;
        if (ctx.PUBLIC() != null) {
            visibility = Visibility.PUBLIC;
            token = ctx.PUBLIC().getSymbol();
        } else if (ctx.PRIVATE() != null) {
            visibility = Visibility.PRIVATE;
            token = ctx.PRIVATE().getSymbol();
        } else if (ctx.PROTECTED() != null) {
            visibility = Visibility.PROTECTED;
            token = ctx.PROTECTED().getSymbol();
        } else {
            // Should not happen based on grammar, but handle defensively
            visibility = Visibility.PUBLIC; // Or throw an error
            token = ctx.getStart(); // Use context start token for position
        }
        return new VisibilityNode(visibility, getLine(token), getColumn(token));
    }

    // Helper Node for Parameter List processing
    private static class ParameterListNode extends AstNode {
        private final List<ParameterNode> parameters;
        ParameterListNode(List<ParameterNode> parameters, int line, int col) {
            super(line, col);
            this.parameters = parameters;
        }
        List<ParameterNode> getParameters() { return parameters; }
    }

    @Override
    public AstNode visitParameter_list(ChubbyParser.Parameter_listContext ctx) {
        List<ParameterNode> parameters = ctx.parameter().stream()
                .map(this::visitParameter)
                .map(ParameterNode.class::cast)
                .collect(Collectors.toList());
        return new ParameterListNode(parameters, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitParameter(ChubbyParser.ParameterContext ctx) {
        TypeNode type = (TypeNode) visitType_specifier(ctx.type_specifier());
        int arrayDimensions = ctx.LEFT_SQUARE().size();
         if (arrayDimensions > 0) {
            type = new TypeNode(type.getBaseTypeName(), arrayDimensions, type.getLineNumber(), type.getColumnNumber());
        }
        String name = ctx.IDENTIFIER().getText();
        return new ParameterNode(type, name, getLine(ctx.IDENTIFIER().getSymbol()), getColumn(ctx.IDENTIFIER().getSymbol()));
    }

    @Override
    public AstNode visitType_specifier(ChubbyParser.Type_specifierContext ctx) {
        String typeName = ctx.getText();
        return new TypeNode(typeName, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitReturn_type(ChubbyParser.Return_typeContext ctx) {
        if (ctx.VOID() != null) {
            return new TypeNode("void", getLine(ctx.VOID().getSymbol()), getColumn(ctx.VOID().getSymbol()));
        }
        TypeNode type = (TypeNode) visitType_specifier(ctx.type_specifier());
        int arrayDimensions = ctx.LEFT_SQUARE().size();
        if (arrayDimensions > 0) {
            return new TypeNode(type.getBaseTypeName(), arrayDimensions, type.getLineNumber(), type.getColumnNumber());
        }
        return type;
    }

    @Override
    public AstNode visitStatement(ChubbyParser.StatementContext ctx) {
        if (ctx.block_statement() != null) {
            return visitBlock_statement(ctx.block_statement());
        } else if (ctx.simple_statement() != null) {
            return visitSimple_statement(ctx.simple_statement());
        }
        // Should not happen
        return null;
    }

    @Override
    public AstNode visitBlock_statement(ChubbyParser.Block_statementContext ctx) {
        if (ctx.if_statement() != null) return visitIf_statement(ctx.if_statement());
        if (ctx.for_statement() != null) return visitFor_statement(ctx.for_statement());
        if (ctx.while_statement() != null) return visitWhile_statement(ctx.while_statement());
        if (ctx.try_catch_statement() != null) return visitTry_catch_statement(ctx.try_catch_statement());
        // Should not happen
        return null;
    }

    @Override
    public AstNode visitSimple_statement(ChubbyParser.Simple_statementContext ctx) {
        if (ctx.local_variable_declaration() != null) return visitLocal_variable_declaration(ctx.local_variable_declaration());
        if (ctx.assignment_statement() != null) return visitAssignment_statement(ctx.assignment_statement());
        if (ctx.return_statement() != null) return visitReturn_statement(ctx.return_statement());
        if (ctx.break_statement() != null) return visitBreak_statement(ctx.break_statement());
        if (ctx.continue_statement() != null) return visitContinue_statement(ctx.continue_statement());
        if (ctx.throw_statement() != null) return visitThrow_statement(ctx.throw_statement());
        if (ctx.expression() != null) {
            ExpressionNode expr = (ExpressionNode) visitExpression(ctx.expression());
            return new ExpressionStatementNode(expr, getLine(ctx), getColumn(ctx));
        }
        // Should not happen
        return null;
    }

    @Override
    public AstNode visitLocal_variable_declaration(ChubbyParser.Local_variable_declarationContext ctx) {
        TypeNode type = (TypeNode) visitType_specifier(ctx.type_specifier());
        int arrayDimensions = ctx.LEFT_SQUARE().size();
        if (arrayDimensions > 0) {
            type = new TypeNode(type.getBaseTypeName(), arrayDimensions, type.getLineNumber(), type.getColumnNumber());
        }
        String name = ctx.IDENTIFIER().getText();
        ExpressionNode initializer = ctx.expression() != null ? (ExpressionNode) visitExpression(ctx.expression()) : null;
        return new LocalVariableDeclarationNode(type, name, initializer, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitAssignment_statement(ChubbyParser.Assignment_statementContext ctx) {
        LValueNode lValue = (LValueNode) visitLvalue(ctx.lvalue());
        // Get the AssignmentOperatorNode
        AssignmentOperatorNode operatorNode = (AssignmentOperatorNode) visitAssignment_operator(ctx.assignment_operator());
        ExpressionNode rValue = (ExpressionNode) visitExpression(ctx.expression());
        // Pass the node to the constructor
        return new AssignmentStatementNode(lValue, operatorNode, rValue, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitLvalue(ChubbyParser.LvalueContext ctx) {
        if (ctx.IDENTIFIER() != null && ctx.DOT() == null) { // Simple identifier
            return new IdentifierNode(ctx.IDENTIFIER().getText(), getLine(ctx.IDENTIFIER().getSymbol()), getColumn(ctx.IDENTIFIER().getSymbol()));
        } else if (ctx.THIS() != null && ctx.DOT() != null && ctx.IDENTIFIER() != null) { // this.member
            ExpressionNode thisRef = new ThisReferenceNode(getLine(ctx.THIS().getSymbol()), getColumn(ctx.THIS().getSymbol()));
            return new MemberAccessNode(thisRef, ctx.IDENTIFIER().getText(), getLine(ctx), getColumn(ctx));
        } else if (ctx.postfixExpression() != null && ctx.LEFT_SQUARE() != null) { // array[index]
            ExpressionNode arrayExpr = (ExpressionNode) visitPostfixExpression(ctx.postfixExpression());
            ExpressionNode indexExpr = (ExpressionNode) visitExpression(ctx.expression());
            return new ArrayAccessNode(arrayExpr, indexExpr, getLine(ctx), getColumn(ctx));
        } else if (ctx.postfixExpression() != null && ctx.DOT() != null) { // object.member
            ExpressionNode objectExpr = (ExpressionNode) visitPostfixExpression(ctx.postfixExpression());
            return new MemberAccessNode(objectExpr, ctx.IDENTIFIER().getText(), getLine(ctx), getColumn(ctx));
        }
        // Should not happen
        return null;
    }

    @Override
    public AstNode visitAssignment_operator(ChubbyParser.Assignment_operatorContext ctx) {
        AssignmentStatementNode.AssignmentOperator operator;
        Token token;
        if (ctx.ASSIGN() != null) {
            operator = AssignmentStatementNode.AssignmentOperator.ASSIGN;
            token = ctx.ASSIGN().getSymbol();
        } else if (ctx.PLUS_ASSIGN() != null) {
            operator = AssignmentStatementNode.AssignmentOperator.PLUS_ASSIGN;
            token = ctx.PLUS_ASSIGN().getSymbol();
        } else if (ctx.MINUS_ASSIGN() != null) {
            operator = AssignmentStatementNode.AssignmentOperator.MINUS_ASSIGN;
            token = ctx.MINUS_ASSIGN().getSymbol();
        } else if (ctx.MULTIPLY_ASSIGN() != null) {
            operator = AssignmentStatementNode.AssignmentOperator.MULTIPLY_ASSIGN;
            token = ctx.MULTIPLY_ASSIGN().getSymbol();
        } else if (ctx.DIVIDE_ASSIGN() != null) {
            operator = AssignmentStatementNode.AssignmentOperator.DIVIDE_ASSIGN;
            token = ctx.DIVIDE_ASSIGN().getSymbol();
        } else if (ctx.MODULO_ASSIGN() != null) {
            operator = AssignmentStatementNode.AssignmentOperator.MODULUS_ASSIGN;
            token = ctx.MODULO_ASSIGN().getSymbol();
        } else {
            // Should not happen based on grammar
            throw new IllegalStateException("Unknown assignment operator: " + ctx.getText());
        }
        // Return the new node type
        return new AssignmentOperatorNode(operator, getLine(token), getColumn(token));
    }

    @Override
    public AstNode visitReturn_statement(ChubbyParser.Return_statementContext ctx) {
        ExpressionNode returnValue = ctx.expression() != null ? (ExpressionNode) visitExpression(ctx.expression()) : null;
        return new ReturnStatementNode(returnValue, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitBreak_statement(ChubbyParser.Break_statementContext ctx) {
        return new BreakStatementNode(getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitContinue_statement(ChubbyParser.Continue_statementContext ctx) {
        return new ContinueStatementNode(getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitThrow_statement(ChubbyParser.Throw_statementContext ctx) {
        ExpressionNode expression = (ExpressionNode) visitExpression(ctx.expression());
        return new ThrowStatementNode(expression, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitTry_catch_statement(ChubbyParser.Try_catch_statementContext ctx) {
        BlockNode tryBody = createBlockNode(ctx.statement(), 0, ctx.CATCH(0).getSymbol().getTokenIndex());

        List<CatchClauseNode> catchClauses = new ArrayList<>();
        for (int i = 0; i < ctx.CATCH().size(); i++) {
            ParameterNode exceptionParam = (ParameterNode) visitParameter(ctx.parameter(i));
            int startCatchBodyIndex = ctx.RIGHT_PAREN(i).getSymbol().getTokenIndex() + 1;
            int endCatchBodyIndex = (i + 1 < ctx.CATCH().size()) ?
                                    ctx.CATCH(i + 1).getSymbol().getTokenIndex() :
                                    (ctx.FINALLY() != null ? ctx.FINALLY().getSymbol().getTokenIndex() : ctx.ENDTRY().getSymbol().getTokenIndex());
            BlockNode catchBody = createBlockNode(ctx.statement(), startCatchBodyIndex, endCatchBodyIndex);
            catchClauses.add(new CatchClauseNode(exceptionParam, catchBody, getLine(ctx.CATCH(i).getSymbol()), getColumn(ctx.CATCH(i).getSymbol())));
        }

        FinallyClauseNode finallyClause = null;
        if (ctx.FINALLY() != null) {
            int startFinallyBodyIndex = ctx.FINALLY().getSymbol().getTokenIndex() + 1;
            int endFinallyBodyIndex = ctx.ENDTRY().getSymbol().getTokenIndex();
            BlockNode finallyBody = createBlockNode(ctx.statement(), startFinallyBodyIndex, endFinallyBodyIndex);
            finallyClause = new FinallyClauseNode(finallyBody, getLine(ctx.FINALLY().getSymbol()), getColumn(ctx.FINALLY().getSymbol()));
        }

        return new TryCatchStatementNode(tryBody, catchClauses, finallyClause, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitIf_statement(ChubbyParser.If_statementContext ctx) {
        ExpressionNode ifCondition = (ExpressionNode) visitBoolean_expression(ctx.boolean_expression(0));

        int thenStartIndex = ctx.THEN(0).getSymbol().getTokenIndex() + 1;
        int thenEndIndex = ctx.ELSIF().isEmpty() ?
                           (ctx.ELSE() != null ? ctx.ELSE().getSymbol().getTokenIndex() : ctx.ENDIF().getSymbol().getTokenIndex()) :
                           ctx.ELSIF(0).getSymbol().getTokenIndex();
        BlockNode thenBranch = createBlockNode(ctx.statement(), thenStartIndex, thenEndIndex);

        List<IfStatementNode.ElsifBranch> elsifBranches = new ArrayList<>();
        for (int i = 0; i < ctx.ELSIF().size(); i++) {
            ExpressionNode elsifCondition = (ExpressionNode) visitBoolean_expression(ctx.boolean_expression(i + 1));
            int elsifStartIndex = ctx.THEN(i + 1).getSymbol().getTokenIndex() + 1;
            int elsifEndIndex = (i + 1 < ctx.ELSIF().size()) ?
                                ctx.ELSIF(i + 1).getSymbol().getTokenIndex() :
                                (ctx.ELSE() != null ? ctx.ELSE().getSymbol().getTokenIndex() : ctx.ENDIF().getSymbol().getTokenIndex());
            BlockNode elsifBody = createBlockNode(ctx.statement(), elsifStartIndex, elsifEndIndex);
            elsifBranches.add(new IfStatementNode.ElsifBranch(elsifCondition, elsifBody));
        }

        BlockNode elseBranch = null;
        if (ctx.ELSE() != null) {
            int elseStartIndex = ctx.ELSE().getSymbol().getTokenIndex() + 1;
            int elseEndIndex = ctx.ENDIF().getSymbol().getTokenIndex();
            elseBranch = createBlockNode(ctx.statement(), elseStartIndex, elseEndIndex);
        }

        return new IfStatementNode(ifCondition, thenBranch, elsifBranches, elseBranch, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitFor_statement(ChubbyParser.For_statementContext ctx) {
        StatementNode initialization = ctx.for_init() != null ? (StatementNode) visitFor_init(ctx.for_init()) : null;
        ExpressionNode condition = ctx.boolean_expression() != null ? (ExpressionNode) visitBoolean_expression(ctx.boolean_expression()) : null;
        StatementNode update = ctx.for_update() != null ? (StatementNode) visitFor_update(ctx.for_update()) : null;

        int bodyStartIndex = ctx.DO().getSymbol().getTokenIndex() + 1;
        int bodyEndIndex = ctx.ENDFOR().getSymbol().getTokenIndex();
        BlockNode body = createBlockNode(ctx.statement(), bodyStartIndex, bodyEndIndex);

        return new ForStatementNode(initialization, condition, update, body, getLine(ctx), getColumn(ctx));
    }

     @Override
    public AstNode visitFor_init(ChubbyParser.For_initContext ctx) {
        if (ctx.local_variable_declaration() != null) {
            return visitLocal_variable_declaration(ctx.local_variable_declaration());
        } else if (ctx.assignment_statement() != null) {
            return visitAssignment_statement(ctx.assignment_statement());
        }
        return null; // Should not happen
    }

    @Override
    public AstNode visitFor_update(ChubbyParser.For_updateContext ctx) {
        if (ctx.assignment_statement() != null) {
            return visitAssignment_statement(ctx.assignment_statement());
        } else if (ctx.expression() != null) {
            // Wrap expression in an ExpressionStatementNode as update can be just an expression
            ExpressionNode expr = (ExpressionNode) visitExpression(ctx.expression());
            return new ExpressionStatementNode(expr, getLine(ctx), getColumn(ctx));
        }
        return null; // Should not happen
    }

    @Override
    public AstNode visitWhile_statement(ChubbyParser.While_statementContext ctx) {
        ExpressionNode condition = (ExpressionNode) visitBoolean_expression(ctx.boolean_expression());
        int bodyStartIndex = ctx.DO().getSymbol().getTokenIndex() + 1;
        int bodyEndIndex = ctx.ENDWHILE().getSymbol().getTokenIndex();
        BlockNode body = createBlockNode(ctx.statement(), bodyStartIndex, bodyEndIndex);
        return new WhileStatementNode(condition, body, getLine(ctx), getColumn(ctx));
    }

    // Helper to create BlockNode from a list of statements within a specific token range
    private BlockNode createBlockNode(List<ChubbyParser.StatementContext> allStatements, int startIndex, int endIndex) {
        List<StatementNode> blockStatements = allStatements.stream()
                .filter(stmtCtx -> stmtCtx.getStart().getTokenIndex() >= startIndex && stmtCtx.getStop().getTokenIndex() < endIndex)
                .map(this::visitStatement)
                .map(StatementNode.class::cast)
                .collect(Collectors.toList());
        // Use the start token of the first statement in the block for line/col, or default if empty
        int line = blockStatements.isEmpty() ? 0 : blockStatements.get(0).getLineNumber();
        int col = blockStatements.isEmpty() ? 0 : blockStatements.get(0).getColumnNumber();
        return new BlockNode(blockStatements, line, col);
    }

    @Override
    public AstNode visitBoolean_expression(ChubbyParser.Boolean_expressionContext ctx) {
        // Boolean expression is just a logicalOrExpression in the grammar
        return visitLogicalOrExpression(ctx.logicalOrExpression());
    }

    @Override
    public AstNode visitExpression(ChubbyParser.ExpressionContext ctx) {
        // Expression is just a logicalOrExpression in the grammar
        return visitLogicalOrExpression(ctx.logicalOrExpression());
    }

    @Override
    public AstNode visitLogicalOrExpression(ChubbyParser.LogicalOrExpressionContext ctx) {
        if (ctx.logicalAndExpression().size() == 1) {
            return visitLogicalAndExpression(ctx.logicalAndExpression(0));
        }
        ExpressionNode left = (ExpressionNode) visitLogicalAndExpression(ctx.logicalAndExpression(0));
        for (int i = 1; i < ctx.logicalAndExpression().size(); i++) {
            ExpressionNode right = (ExpressionNode) visitLogicalAndExpression(ctx.logicalAndExpression(i));
            left = new BinaryExpressionNode(left, BinaryExpressionNode.Operator.OR, right, getLine(ctx.OR(i - 1).getSymbol()), getColumn(ctx.OR(i - 1).getSymbol()));
        }
        return left;
    }

    @Override
    public AstNode visitLogicalAndExpression(ChubbyParser.LogicalAndExpressionContext ctx) {
        if (ctx.equalityExpression().size() == 1) {
            return visitEqualityExpression(ctx.equalityExpression(0));
        }
        ExpressionNode left = (ExpressionNode) visitEqualityExpression(ctx.equalityExpression(0));
        for (int i = 1; i < ctx.equalityExpression().size(); i++) {
            ExpressionNode right = (ExpressionNode) visitEqualityExpression(ctx.equalityExpression(i));
            left = new BinaryExpressionNode(left, BinaryExpressionNode.Operator.AND, right, getLine(ctx.AND(i - 1).getSymbol()), getColumn(ctx.AND(i - 1).getSymbol()));
        }
        return left;
    }

    @Override
    public AstNode visitEqualityExpression(ChubbyParser.EqualityExpressionContext ctx) {
        if (ctx.relationalExpression().size() == 1) {
            return visitRelationalExpression(ctx.relationalExpression(0));
        }
        ExpressionNode left = (ExpressionNode) visitRelationalExpression(ctx.relationalExpression(0));
        for (int i = 1; i < ctx.relationalExpression().size(); i++) {
            ExpressionNode right = (ExpressionNode) visitRelationalExpression(ctx.relationalExpression(i));
            BinaryExpressionNode.Operator op;
            Token opToken;
            if (ctx.EQUAL(i - 1) != null) {
                op = BinaryExpressionNode.Operator.EQUAL;
                opToken = ctx.EQUAL(i - 1).getSymbol();
            } else {
                op = BinaryExpressionNode.Operator.NOT_EQUAL;
                opToken = ctx.NOT_EQUAL(i - 1).getSymbol();
            }
            left = new BinaryExpressionNode(left, op, right, getLine(opToken), getColumn(opToken));
        }
        return left;
    }

    @Override
    public AstNode visitRelationalExpression(ChubbyParser.RelationalExpressionContext ctx) {
        if (ctx.additiveExpression().size() == 1) {
            return visitAdditiveExpression(ctx.additiveExpression(0));
        }
        ExpressionNode left = (ExpressionNode) visitAdditiveExpression(ctx.additiveExpression(0));
        for (int i = 1; i < ctx.additiveExpression().size(); i++) {
            ExpressionNode right = (ExpressionNode) visitAdditiveExpression(ctx.additiveExpression(i));
            BinaryExpressionNode.Operator op;
            Token opToken;
            if (ctx.LESS(i - 1) != null) {
                op = BinaryExpressionNode.Operator.LESS;
                opToken = ctx.LESS(i - 1).getSymbol();
            } else if (ctx.GREATER(i - 1) != null) {
                op = BinaryExpressionNode.Operator.GREATER;
                opToken = ctx.GREATER(i - 1).getSymbol();
            } else if (ctx.LESS_EQUAL(i - 1) != null) {
                op = BinaryExpressionNode.Operator.LESS_EQUAL;
                opToken = ctx.LESS_EQUAL(i - 1).getSymbol();
            } else { // GREATER_EQUAL
                op = BinaryExpressionNode.Operator.GREATER_EQUAL;
                opToken = ctx.GREATER_EQUAL(i - 1).getSymbol();
            }
            left = new BinaryExpressionNode(left, op, right, getLine(opToken), getColumn(opToken));
        }
        return left;
    }

    @Override
    public AstNode visitAdditiveExpression(ChubbyParser.AdditiveExpressionContext ctx) {
        if (ctx.multiplicativeExpression().size() == 1) {
            return visitMultiplicativeExpression(ctx.multiplicativeExpression(0));
        }
        ExpressionNode left = (ExpressionNode) visitMultiplicativeExpression(ctx.multiplicativeExpression(0));
        for (int i = 1; i < ctx.multiplicativeExpression().size(); i++) {
            ExpressionNode right = (ExpressionNode) visitMultiplicativeExpression(ctx.multiplicativeExpression(i));
            BinaryExpressionNode.Operator op;
            Token opToken;
            if (ctx.PLUS(i - 1) != null) {
                op = BinaryExpressionNode.Operator.PLUS;
                opToken = ctx.PLUS(i - 1).getSymbol();
            } else { // MINUS
                op = BinaryExpressionNode.Operator.MINUS;
                opToken = ctx.MINUS(i - 1).getSymbol();
            }
            left = new BinaryExpressionNode(left, op, right, getLine(opToken), getColumn(opToken));
        }
        return left;
    }

    @Override
    public AstNode visitMultiplicativeExpression(ChubbyParser.MultiplicativeExpressionContext ctx) {
        if (ctx.unaryExpression().size() == 1) {
            return visitUnaryExpression(ctx.unaryExpression(0));
        }
        ExpressionNode left = (ExpressionNode) visitUnaryExpression(ctx.unaryExpression(0));
        for (int i = 1; i < ctx.unaryExpression().size(); i++) {
            ExpressionNode right = (ExpressionNode) visitUnaryExpression(ctx.unaryExpression(i));
            BinaryExpressionNode.Operator op;
            Token opToken;
            if (ctx.MULTIPLY(i - 1) != null) {
                op = BinaryExpressionNode.Operator.MULTIPLY;
                opToken = ctx.MULTIPLY(i - 1).getSymbol();
            } else if (ctx.DIVIDE(i - 1) != null) {
                op = BinaryExpressionNode.Operator.DIVIDE;
                opToken = ctx.DIVIDE(i - 1).getSymbol();
            } else { // MODULO
                op = BinaryExpressionNode.Operator.MODULO;
                opToken = ctx.MODULO(i - 1).getSymbol();
            }
            left = new BinaryExpressionNode(left, op, right, getLine(opToken), getColumn(opToken));
        }
        return left;
    }

    @Override
    public AstNode visitUnaryExpression(ChubbyParser.UnaryExpressionContext ctx) {
        if (ctx.postfixExpression() != null) {
            return visitPostfixExpression(ctx.postfixExpression());
        }
        ExpressionNode operand = (ExpressionNode) visitUnaryExpression(ctx.unaryExpression());
        UnaryExpressionNode.Operator op;
        Token opToken;
        if (ctx.PLUS() != null) {
            op = UnaryExpressionNode.Operator.PLUS;
            opToken = ctx.PLUS().getSymbol();
        } else if (ctx.MINUS() != null) {
            op = UnaryExpressionNode.Operator.MINUS;
            opToken = ctx.MINUS().getSymbol();
        } else { // NOT
            op = UnaryExpressionNode.Operator.NOT;
            opToken = ctx.NOT().getSymbol();
        }
        return new UnaryExpressionNode(op, operand, getLine(opToken), getColumn(opToken));
    }

    @Override
    public AstNode visitPostfixExpression(ChubbyParser.PostfixExpressionContext ctx) {
        ExpressionNode baseExpr = (ExpressionNode) visitPrimaryExpression(ctx.primaryExpression());

        // Process postfix operations iteratively
        for (int i = 0; i < ctx.getChildCount(); i++) {
            ParseTree child = ctx.getChild(i);
            if (child instanceof TerminalNode) {
                TerminalNode node = (TerminalNode) child;
                if (node.getSymbol().getType() == ChubbyParser.DOT) {
                    // Member access: baseExpr.IDENTIFIER
                    String memberName = ctx.IDENTIFIER(ctx.DOT().indexOf(node)).getText(); // Find corresponding IDENTIFIER
                    baseExpr = new MemberAccessNode(baseExpr, memberName, getLine(node.getSymbol()), getColumn(node.getSymbol()));
                } else if (node.getSymbol().getType() == ChubbyParser.LEFT_SQUARE) {
                    // Array access: baseExpr[expression]
                    // Find the corresponding expression context
                    int exprIndex = findExpressionIndexForBracket(ctx, node);
                    ExpressionNode indexExpr = (ExpressionNode) visitExpression(ctx.expression(exprIndex));
                    baseExpr = new ArrayAccessNode(baseExpr, indexExpr, getLine(node.getSymbol()), getColumn(node.getSymbol()));
                } else if (node.getSymbol().getType() == ChubbyParser.LEFT_PAREN) {
                    // Function call: baseExpr(argument_list?)
                    // Find the corresponding argument_list context
                    int argListIndex = findArgumentListIndexForParen(ctx, node);
                    List<ExpressionNode> arguments = (argListIndex != -1 && ctx.argument_list(argListIndex) != null) ?
                            ((ArgumentListNode) visitArgument_list(ctx.argument_list(argListIndex))).getArguments() :
                            Collections.emptyList();
                    baseExpr = new FunctionCallNode(baseExpr, arguments, getLine(node.getSymbol()), getColumn(node.getSymbol()));
                }
            }
        }
        return baseExpr;
    }

    // Helper to find the index of the expression corresponding to a specific '['
    private int findExpressionIndexForBracket(ChubbyParser.PostfixExpressionContext ctx, TerminalNode bracketNode) {
        int bracketCount = 0;
        for(TerminalNode node : ctx.LEFT_SQUARE()) {
            if (node == bracketNode) {
                return bracketCount;
            }
            bracketCount++;
        }
        return -1; // Should not happen
    }

    // Helper to find the index of the argument_list corresponding to a specific '('
    private int findArgumentListIndexForParen(ChubbyParser.PostfixExpressionContext ctx, TerminalNode parenNode) {
        int parenCount = 0;
        for(TerminalNode node : ctx.LEFT_PAREN()) {
            if (node == parenNode) {
                return parenCount;
            }
            parenCount++;
        }
        return -1; // Should not happen
    }


    @Override
    public AstNode visitPrimaryExpression(ChubbyParser.PrimaryExpressionContext ctx) {
        if (ctx.literal() != null) {
            return visitLiteral(ctx.literal());
        } else if (ctx.IDENTIFIER() != null) {
            return new IdentifierNode(ctx.IDENTIFIER().getText(), getLine(ctx.IDENTIFIER().getSymbol()), getColumn(ctx.IDENTIFIER().getSymbol()));
        } else if (ctx.expression() != null) {
            // Parenthesized expression
            return visitExpression(ctx.expression());
        } else if (ctx.object_creation() != null) {
            return visitObject_creation(ctx.object_creation());
        } else if (ctx.THIS() != null) {
            return new ThisReferenceNode(getLine(ctx.THIS().getSymbol()), getColumn(ctx.THIS().getSymbol()));
        }
        // Should not happen
        return null;
    }

    // Helper Node for Argument List processing
    private static class ArgumentListNode extends AstNode {
        private final List<ExpressionNode> arguments;
        ArgumentListNode(List<ExpressionNode> arguments, int line, int col) {
            super(line, col);
            this.arguments = arguments;
        }
        List<ExpressionNode> getArguments() { return arguments; }
    }

    @Override
    public AstNode visitArgument_list(ChubbyParser.Argument_listContext ctx) {
        List<ExpressionNode> arguments = ctx.expression().stream()
                .map(this::visitExpression)
                .map(ExpressionNode.class::cast)
                .collect(Collectors.toList());
        return new ArgumentListNode(arguments, getLine(ctx), getColumn(ctx));
    }

    @Override
    public AstNode visitObject_creation(ChubbyParser.Object_creationContext ctx) {
        TypeNode type = (TypeNode) visitType_specifier(ctx.type_specifier());
        int line = getLine(ctx.NEW().getSymbol());
        int col = getColumn(ctx.NEW().getSymbol());

        if (ctx.LEFT_PAREN() != null) { // Object creation: new Type(args?)
            List<ExpressionNode> arguments = ctx.argument_list() != null ?
                    ((ArgumentListNode) visitArgument_list(ctx.argument_list())).getArguments() :
                    Collections.emptyList();
            return new ObjectCreationNode(type, arguments, line, col);
        } else { // Array creation: new Type[size]+
            List<ExpressionNode> dimensionSizes = ctx.expression().stream()
                    .map(this::visitExpression)
                    .map(ExpressionNode.class::cast)
                    .collect(Collectors.toList());
            // Note: The grammar implies elementType is just the base type.
            // The full array type (e.g., int[][]) is implicitly defined by the dimensions.
            return new ArrayCreationNode(type, dimensionSizes, line, col);
        }
    }

    @Override
    public AstNode visitLiteral(ChubbyParser.LiteralContext ctx) {
        if (ctx.INTEGER_LITERAL() != null) {
            return new IntegerLiteralNode(Integer.parseInt(ctx.INTEGER_LITERAL().getText()), getLine(ctx), getColumn(ctx));
        } else if (ctx.FLOAT_LITERAL() != null) {
            // Remove 'f' or 'F' suffix before parsing
            String floatText = ctx.FLOAT_LITERAL().getText().toUpperCase().replace("F", "");
            return new FloatLiteralNode(Float.parseFloat(floatText), getLine(ctx), getColumn(ctx));
        } else if (ctx.DOUBLE_LITERAL() != null) {
            // Remove 'd' or 'D' suffix if present
            String doubleText = ctx.DOUBLE_LITERAL().getText().toUpperCase().replace("D", "");
            return new DoubleLiteralNode(Double.parseDouble(doubleText), getLine(ctx), getColumn(ctx));
        } else if (ctx.CHAR_LITERAL() != null) {
            // Remove quotes and handle escape sequences if necessary (basic handling here)
            String charText = ctx.CHAR_LITERAL().getText();
            char value = charText.substring(1, charText.length() - 1).charAt(0); // Basic, assumes no complex escapes
             if (charText.length() > 3 && charText.charAt(1) == '\\') { // Handle simple escapes like \n, \t, \\, \'
                switch (charText.charAt(2)) {
                    case 'n': value = '\n'; break;
                    case 't': value = '\t'; break;
                    case '\\': value = '\\'; break;
                    case '\'': value = '\''; break;
                    // Add other escapes if needed
                }
            }
            return new CharLiteralNode(value, getLine(ctx), getColumn(ctx));
        } else if (ctx.STRING_LITERAL() != null) {
            // Remove quotes and handle escape sequences (basic handling here)
            String stringText = ctx.STRING_LITERAL().getText();
            String value = stringText.substring(1, stringText.length() - 1);
            // Basic escape handling (replace \\ with \ and \" with ")
            value = value.replace("\\\\", "\\").replace("\\\"", "\"");
            // Add other escapes if needed (\n, \t etc.)
            value = value.replace("\\n", "\n").replace("\\t", "\t");
            return new StringLiteralNode(value, getLine(ctx), getColumn(ctx));
        } else if (ctx.TRUE() != null) {
            return new BooleanLiteralNode(true, getLine(ctx), getColumn(ctx));
        } else if (ctx.FALSE() != null) {
            return new BooleanLiteralNode(false, getLine(ctx), getColumn(ctx));
        } else if (ctx.NULL() != null) {
            // Representing null might require a specific NullLiteralNode or handling in type checking
            return new NullLiteralNode(getLine(ctx), getColumn(ctx));
        }
        // Should not happen
        return null;
    }
}
